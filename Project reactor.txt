Реактивная архитектура - если говорить про реактивную архитектуру, то у нас есть 3 основных компонента на уровне ОС, это event-loop, selector и само ядро. 
Фактически, сама реактивщина происхоидт следующим образом. 
 - Есть поток операционной системы, который вызывает event-loop и выполняет какой-то сетевой вызов, этот поток блокируется, когда выполняет сетевой вызов (select(), epoll_wait(), kqueue()).
 - Есть selector, задача которого состоит в том, чтобы отслеживать разные низкоуровневые сетевые ресурсы (Сокеты, TCP/UDP, каналы)
 - Когда в этих сетевых ресурсах происходит событие, тогда ядро ОС перемещает это событие в очередь
 - Затем selector считывает событие и передает в event-loop
 - А event-loop уже знает как обработать это событие, происходит вызов netty-handler и в результате мы получаем reactive stream (publisher-subscriber)

Асинхронность достигается тем, что event-loop может обрабатывать множество соединений без создания отдельного потока на каждое соединение.

Как это работает в контексте Project reactor - если говорить в контексте Project Reactor, то этот механизм начинает работать, когда мы вызываем метод subscribe.
 - Мы вызываем subscribe и Reactor регистрирует мой callback (onNext, onError, onComplet) в scheduler, который привязан к Netty event-loop
 - Netty создает сокет на нашу операцию (сокет к внешнему сервису, к которому мы обращаемся)и event-loop запускается
 - Selector ждет события в очереди, когда событие происходит, selector передает это событие в event-loop
 - и event-loop уже обрабатывает эти данные 

Дескриптор - это указатель на ресурсы в ОС.
 - Сетевые сокеты
 - Файлы
 - Каналы

Как событие попадает в очередь ОС
 - ОС следит за состоянием сетевых ресурсов
 - Когда происходит событие (например, на сокете появились новые данные), ядро ОС фиксирует, что ресурс готов.
 - Ядро помещает дескриптор события в внутреннюю очередь готовых событий
 - Selector читает очередь и возвращает данные в event loop, а event-loop вызывает handler



